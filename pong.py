# Pre-Poke Framework
# Implements a general game template for games with animation
# You must use this template for all your graphical lab assignments
# and you are only allowed to inlclude additional modules that are part of
# the Python Standard Library; no other modules are allowed

import pygame

class Game:
    def __init__(self, game_surface):
        self.surface = game_surface
        self.bg_color = pygame.Color('black')
        self.game_clock = pygame.time.Clock()
        self.fps = 30
        self.continue_game = True
        self.close_clicked = False
        # the Ball
        self.Ball_center = [250, 200]
        self.Ball_radius = 5   
        self.Ball = Ball(self.Ball_center,self.Ball_radius,3,3)
        # player1's paddle
        self.player1_left = 100
        self.player1_top = 185
        self.player1_width = 5
        self.player1_length = 30
        self.player1 = Paddle(self.player1_left,self.player1_top,self.player1_width, self.player1_length)        
        # player2's paddle
        self.player2_left = 390
        self.player2_top = 185
        self.player2_width = 5
        self.player2_length = 30        
        self.player2 = Paddle(self.player2_left,self.player2_top,self.player2_width, self.player2_length)
        # players' score
        self.player1_score = Score([10,1])
        self.player2_score = Score([460,1])     

    def play(self):
        # Play the game until the player presses the close box.
        # self is the Game that should be continued or not.
        while not self.close_clicked:  # until player clicks close box
            self.handle_events()
            # draw objects
            self.draw()
            # if the game is running, then it will handle the inputs
            if self.continue_game:
                self.update()
                self.decide_continue()  # this will decide whether the game should continue or not      
            self.game_clock.tick(self.fps)  # run at most with FPS Frames Per Second         

    def handle_events(self):
        # Handle each user event by changing the game state appropriately.
        # self is the Game whose events will be handled
        for event in pygame.event.get():
            if event.type == pygame.QUIT: 
                self.close_clicked = True
            # these two are the keyboard input generated by the player
            self.player1_control(event)
            self.player2_control(event) 


    def draw(self):
        # Draw all game objects.
        # self is the Game to draw       
        self.surface.fill(self.bg_color)  # clear the display surface first
        self.Ball.draw(self.surface)
        self.player1.draw(self.surface)
        self.player2.draw(self.surface)
        self.player1_score.draw(self.surface)
        self.player2_score.draw(self.surface)
        pygame.display.flip()  # render all drawn objects to the screen        

    def update(self):
        # Update the game objects for the next frame.
        # self is the Game to update    
        self.player1.move()  
        self.player2.move()
        self.Ball.move(self.player1,self.player2)
        self.player1_score.left_score(self.Ball_center)
        self.player2_score.right_score(self.Ball_center)        
    
    def decide_continue(self):
        # Check whether the game should continue or not
        # if any player'score reaches 11, then the game stop
        if self.player1_score.score >= 11 or self.player2_score.score >= 11:
            self.continue_game = False
    
    def player1_control(self,event):
        # this controls the paddle movement
        # when the self.player1.up is false, the velocity is 0
        # when the self.player1.up is true, the velocity is NEGATIVE
        # when the self.player1.down is false, the velocity is 0 
        # when the self.player1.down is true, the velocity is POSITIVE
        if event.type == pygame.KEYUP :
            if event.key == pygame.K_q:  
                self.player1.up = False
            if event.key == pygame.K_a:
                self.player1.down = False 
        if event.type == pygame.KEYDOWN :
            if event.key == pygame.K_q:
                self.player1.up = True
            if event.key == pygame.K_a:
                self.player1.down = True  
    
    def player2_control(self,event):
        # this controls the paddle movement
        # when the self.player2.up is false, the velocity is 0
        # when the self.player2.up is true, the velocity is NEGATIVE
        # when the self.player2.down is false, the velocity is 0 
        # when the self.player2.down is true, the velocity is POSITIVE
        if event.type == pygame.KEYUP :
            if event.key == pygame.K_p:
                self.player2.up = False  
            if event.key == pygame.K_l:
                self.player2.down = False      
        if event.type == pygame.KEYDOWN :
            if event.key == pygame.K_p:
                self.player2.up = True  
            if event.key == pygame.K_l:
                self.player2.down = True   
    

class Ball:
    def __init__(self,center, radius, x_velocity, y_velocity):
        self.center = center
        self.radius = radius
        self.color = pygame.Color("white")
        # the velocity is the Ball speed
        self.x_velocity = x_velocity
        self.y_velocity = y_velocity
        
    def draw(self,screen):
        # this will draw a circle at the self.center position
        pygame.draw.circle(screen,self.color,self.center,self.radius)
        
    def move(self, paddle1,paddle2):
        # the below controls the rebounce when the Ball hits boundary
        if self.center[0] <= self.radius:  
            self.x_velocity = - self.x_velocity
        if self.center[1] <= self.radius:  
            self.y_velocity = - self.y_velocity
        if self.center[0] >= 500 - self.radius: 
            self.x_velocity = - self.x_velocity
        if self.center[1] >= 400 - self.radius: 
            self.y_velocity = - self.y_velocity
        # the below controls the rebounce when the Ball hits paddles    
        collide1 = paddle1.collide((self.center[0]-5,self.center[1]))  # a boolean value determine whether collide or not
        collide2 = paddle2.collide((self.center[0]+5,self.center[1]))  
        if collide1 and self.x_velocity < 0:
            self.x_velocity = - self.x_velocity
        if collide2 and self.x_velocity > 0:
            self.x_velocity = - self.x_velocity  
        self.center[0] = self.center[0] + self.x_velocity
        self.center[1] = self.center[1] + self.y_velocity        
        
class Paddle:
    # some start setup
    def __init__(self,left,top,width,length):
        self.left = left
        self.top = top
        self.frame = [self.left,self.top]
        self.color = pygame.Color("white")
        self.width = width
        self.length = length
        # this is using to create a rectangle object
        # but it won't be draw on the screen directly
        self.rect = pygame.Rect(self.left, self.top, self.width,self.length)
        self.velocity = 0
        self.speed = 8
        # these two are in order to control the movement of paddles
        self.up = False
        self.down = False
    
    def draw(self,screen):
        # draw the rectangle on the screen
        pygame.draw.rect(screen, self.color, self.rect)
    
    def move(self):
        # the below statements will control the movement of paddles
        self.velocity = 0  # this will refresh to 0 when you call this method
        #  otherwise, the paddle will not stop
        # self.up means you press the "up key" and haven't released yet
        # self.down means you press the "down key" and haven't released yet
        # the self.frame here is in order to not let paddle gets outside of our frame
        if self.up and not self.top < 0 :  
            self.velocity = -self.speed
        if self.down and not self.top > 370 :
            self.velocity = self.speed 
        # this is using to change the paddle position
        self.top = self.top + self.velocity
        # this will creat a new rect object but haven't drew yet
        self.rect = pygame.Rect(self.left, self.top,self.width ,self.length)
    
    def collide(self,point):
        return self.rect.collidepoint(point)

class Score:
    def __init__(self,position):
        # regular start setup
        self.color = pygame.Color("white")
        self.position = position
        self.font = pygame.font.SysFont('Times New Roman', 45, bold=True)
        self.score = 0
        
    def draw(self,screen):
        # the content of that text will be created as a pygame object
        text_image = self.font.render(str(self.score), True, self.color)
        # draw it on the screen
        screen.blit(text_image, self.position)     
    
    def left_score(self, Ball_center):  
        # this means the score on the left side will plus 1
        if  Ball_center[0] < 5:
            self.score = self.score + 1
            
    def right_score(self, Ball_center):
        # this means the score on the right side will plus 1
        if  Ball_center[0] > 495:
            self.score = self.score + 1        

def main():
    # initialize all pygame modules (some need initialization)
    pygame.init()    
    # create a pygame display window
    pygame.display.set_mode((500, 400))  
    # set the title of the display window
    pygame.display.set_caption('Pong')   
    # get the display surface
    w_surface = pygame.display.get_surface() 
    # create a game object
    game = Game(w_surface)
    # start the main game loop by calling the play method on the game object
    game.play() 
    # quit pygame and clean up the pygame window
    pygame.quit() 

main()
        
        
    
